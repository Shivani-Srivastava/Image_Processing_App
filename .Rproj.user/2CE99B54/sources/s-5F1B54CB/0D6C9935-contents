---
title: "lpSolve shiny-able codebase"
output:
  html_document:
    df_print: paged
---

Below is code to be wrapped in shiny and deployed in MLBM for doing basic linear programming (and integer programming) problems using `lpSolve1 in R.

Two examples presented. First one taken from here: https://finnstats.com/index.php/2021/04/12/linear-optimization-using-r/

First things first, setup chunk.

```{r}
library(lpSolve)
library(stringr)
library(tidyverse)
```

Now, the problem statement definition:
> Suppose a company wants to maximize the profit for two products A and B which are sold at $25 and $20 respectively. There are 1800 resource units available every day and product A requires 20 units while B requires 12 units. Both of these products require a production time of 4 minutes and the total available working hours are 8 in a day. What should be the production quantity for each of the products to maximize profits?

Above problem can be formulated as an objective func to be maximized subject to 2 contraints (resource and time).

## UI side user inputs needed

Following user inputs will be required, using decision variables x1, x2,...

```{r}
## user inputs
n0 = 2  # num of decision variables. select from dropdown.
n1 = 2 # num of constraints. dropdown.
obj.type = "max" # alternately, "min"
int0 = "FALSE"  # default. if "TRUE" ony integer soln is found

obj.func.string = "sales = 25x1 +20*x2" # give field for writing this. user inputs only the string

# make n1 fields for accepting constraint input.
constr1 = "20x1 + 12x2 <= 1800" # resource constraint 
constr2 = "4x1 + 4x2 <= 480" # time constraint 

```

## Server side processing

Need to define 2 general funcs to parse the obj.fun.string and the constraints obj above.

```{r}
# parse obj func and ID coeffs
parse_obj_fn <- function(str1){
  obj.in = str_replace_all(str1, "[\\*\\s]?x\\d+", "x") %>% 
    str_extract_all(., "[-]?\\s?\\d+x") %>% unlist() %>%
    str_extract_all("[-]?\\d+") %>% 
    unlist() %>% as.numeric()
  return(obj.in)}

# parse constr and ID coeffs for constr.mat
parse_constr <- function(constr1){
  constr.in = str_replace_all(constr1, "\\*?x\\d+", "x") %>% 
    str_extract_all(., "[-]?\\s?\\d+") %>% unlist() %>% 
    str_replace_all(., "\\s", "") %>%
    unlist() %>% as.numeric()
  return(constr.in)}

```

Now, we create empty objects required by the `lp()` func. 

Will parse user input and populate these empty objs.

```{r}
# create shell objs to populate
constr = c(constr1, constr2) # binding user input into a list
constr.mat = matrix(0, nrow=n1, ncol=n0); constr.mat
constr.rhs = matrix(0, nrow=n1, ncol=1); constr.rhs
constr.dir = vector(mode="list", length=n1)  # Const.dir<-c("<","<=")
```

Now, time to populate these objs

```{r}
obj.in = parse_obj_fn(obj.func.string); obj.in

for (i0 in 1:n1){
  a0 = parse_constr(constr[i0]); a0
  constr.mat[i0, 1:n0] = a0[1:n0]
  constr.rhs[i0, 1] = a0[length(a0)]
  constr.dir[i0] = str_extract_all(constr[i0], "[<>=]")[[1]] %>% 
    str_c(collapse="") %>% unlist()
}
constr.dir = constr.dir %>% unlist()
```

Finally, setup is done. Time for the main processing step.

```{r}
# run LP solver
if (int0 == "TRUE"){
  optimum <- lp(direction=obj.type, obj.in, constr.mat, constr.dir, constr.rhs, all.int=T)
              } else {
                  
  optimum <- lp(direction=obj.type, obj.in, constr.mat, constr.dir, constr.rhs)    
                }

```

If all goes well, then we have the output object `optimum` which we will prep for display.

```{r}
# prep output for display
varnames0 = vector(mode="list", length=n0) 
for (i in 1:n0){varnames0[i] = paste0("x",i)}
varnames0 = varnames0 %>% unlist()

solution_df = data.frame(variable = varnames0, value = optimum$solution)
solution_df  # display this

optimum   # display this
```

Dassit. Done. Would have beennice to have some graphical ways to display output as well, however. 

Here's another example, more complex along similar lines.

## More complex example

Example 2 taken from: https://rpubs.com/nayefahmad/linear-programming

> A company produces two models of chairs: 4P and 3P. The model 4P needs 4 legs, 1 seat and 1 back. On the other hand, the model 3P needs 3 legs and 1 seat. The company has a initial stock of 200 legs, 500 seats and 100 backs. If the company needs more legs, seats and backs, it can buy standard wood blocks, whose cost is 80 euro per block. The company can produce 10 seats, 20 legs and 2 backs from a standard wood block. The cost of producing the model 4P is 30 euro/chair, meanwhile the cost of the model 3P is 40 euro/chair. Finally, the company informs that the minimum number of chairs to produce is 1000 units per month. Define a linear programming model, which minimizes the total cost (the production costs of the two chairs, plus the buying of new wood blocks).

Again, let's start with user input.

```{r}
# let num of 4P, 3P and woodBlox = x1, x2 and x3 resp. Then UI inputs are:
n0 = 3 # num of decision vars
n1 = 4 # num of constraints
int0 = "TRUE"  # whether solution is integer or real num. UI needed

obj.func.string = "cost = 30*x1 + 40*x2 + 80*x3"
obj.type = "min"  # "max" is other option
constr1 = "4x1 + 3x2 - 20x3 <= 200"
constr2 = "1x1 + 1*x2 - 10x3 <= 500"
constr3 = "1x1 + 0x2 - 2x3 <= 100"
constr4 = "1x1 + 1x2 + 0*x3 >= 1000"
```

Since funcs are already defined above, will invoke them directly here.

Creaing shell objs to populate.

```{r}
constr = c(constr1, constr2, constr3, constr4)
constr.mat = matrix(0, nrow=n1, ncol=n0); constr.mat
constr.rhs = matrix(0, nrow=n1, ncol=1); constr.rhs
constr.dir = vector(mode="list", length=n1)  # Const.dir<-c("<","<="
```

Now populating the shell objs created.

```{r}
obj.in = parse_obj_fn(obj.func.string); obj.in

for (i0 in 1:n1){
  a0 = parse_constr(constr[i0]); a0
  constr.mat[i0, 1:n0] = a0[1:n0]
  constr.rhs[i0, 1] = a0[length(a0)]
  constr.dir[i0] = str_extract_all(constr[i0], "[<>=]")[[1]] %>% 
    str_c(collapse="") %>% unlist()
}
constr.dir = constr.dir %>% unlist()

constr.mat; constr.rhs; constr.dir
```

Now running the rest, same as above.

```{r}
# run LP solver
if (int0 == "TRUE"){
  optimum <- lp(direction=obj.type, obj.in, constr.mat, constr.dir, constr.rhs, all.int=T)
              } else {
                  
  optimum <- lp(direction=obj.type, obj.in, constr.mat, constr.dir, constr.rhs)    
                }

# prep output for display
varnames0 = vector(mode="list", length=n0) 
for (i in 1:n0){varnames0[i] = paste0("x",i)}
varnames0 = varnames0 %>% unlist()

solution_df = data.frame(variable = varnames0, value = optimum$solution)
solution_df

optimum
```

Chalo, will stop here. I thnk we think we have enough to build a shiny wrapper around this code.

The UI is a little involved and the better part of a lecture will go in instructing folks in how to formulate and input the required inputs.

Ciao.